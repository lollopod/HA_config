"use strict";
// import * as rm from 'typed-rest-client/RestClient';
// import * as restm from 'typed-rest-client/RestClient';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var httpm = __importStar(require("typed-rest-client/HttpClient"));
var hm = __importStar(require("typed-rest-client/Handlers"));
var WebSocket = require('universal-websocket-client');
var winston_1 = require("winston");
var WebhookRelayEvent_1 = require("./Messages/WebhookRelayEvent");
// let baseUrl: string = 'https://bin.webhookrelay.com/v1/webhooks/c6647f06-3636-405c-93df-c4ac678b16fb';
var WebhookRelayClient = /** @class */ (function () {
    /** @private */
    function WebhookRelayClient(key, secret, buckets, handler) {
        this.key = key;
        this._key = '';
        this._secret = '';
        this._buckets = [];
        this._api = 'https://my.webhookrelay.com'; // API address
        this._connecting = false;
        this._manualDisconnect = false;
        this._connected = false;
        this._reconnectInterval = 1000 * 3;
        this._missingPingThreshold = 90000; // 90 seconds (pings should be every 1 minute)
        this._key = key;
        this._secret = secret;
        this._buckets = buckets;
        this._handler = handler;
        this._logger = winston_1.createLogger({
            transports: [
                new winston_1.transports.Console(),
            ]
        });
    }
    WebhookRelayClient.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        if (_this._connected) {
                            resolve();
                            return;
                        }
                        _this._connecting = true;
                        _this._socket = new WebSocket('wss://my.webhookrelay.com/v1/socket');
                        _this._socket.onopen = function (event) {
                            _this._connected = true;
                            _this._connecting = false;
                            _this._sendMessage({ action: 'auth', key: _this._key, secret: _this._secret });
                            resolve();
                        };
                        _this._socket.onmessage = function (event) {
                            _this._receiveMessage(event.data);
                        };
                        _this._socket.onerror = function (event) {
                            _this._logger.error("websocket error: " + event);
                        };
                        _this._socket.onclose = function (event) {
                            _this._socket = undefined;
                            _this._connected = false;
                            _this._connecting = false;
                            if (_this._manualDisconnect) {
                                // nothing to do, manual disconnect                    
                                _this._logger.info('manual disconnect');
                                return;
                            }
                            _this._logger.info('connection closed, reconnecting..');
                            setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    this._reconnect();
                                    return [2 /*return*/];
                                });
                            }); }, _this._reconnectInterval);
                        };
                    })];
            });
        });
    };
    WebhookRelayClient.prototype.respond = function (responseJSON) {
        return __awaiter(this, void 0, void 0, function () {
            var response, payload, basicHandler, httpc, res, body, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 4, , 5]);
                        if (responseJSON.length === 0) {
                            console.error('Response message cannot be empty');
                            return [2 /*return*/];
                        }
                        response = WebhookRelayEvent_1.ResponseMessage.fromJSON(responseJSON);
                        if (response.getMeta() === undefined) {
                            console.error('Response meta property is missing, ensure that you are passing the same meta from the original payload. Schema can be found here: https://webhookrelay.com/v1/guide/socket-server.html#Schema');
                            return [2 /*return*/];
                        }
                        if (response.getMeta().id === '' || response.getMeta().id === null) {
                            console.error('Response meta.id property cannot be empty. Based on this property response can be updated in the system, please pass the whole meta object that you received from Webhook Relay WebSocket server');
                            return [2 /*return*/];
                        }
                        payload = {
                            id: response.getMeta().id,
                            bucket_id: response.getMeta().bucket_id,
                            response_body: Buffer.from(response.getBody()).toString('base64'),
                            status_code: response.getStatus(),
                            response_headers: response.getHeaders()
                        };
                        basicHandler = new hm.BasicCredentialHandler(this._key, this._secret);
                        httpc = new httpm.HttpClient('webhookrelay-ws-client', [basicHandler]);
                        return [4 /*yield*/, httpc.put(this._api + '/v1/logs/' + payload.id, JSON.stringify(payload))];
                    case 1:
                        res = _a.sent();
                        if (!(res.message.statusCode !== 200)) return [3 /*break*/, 3];
                        return [4 /*yield*/, res.readBody()];
                    case 2:
                        body = _a.sent();
                        console.error("Unexpected response from Webhook Relay API (" + res.message.statusCode + "): " + body);
                        _a.label = 3;
                    case 3: return [3 /*break*/, 5];
                    case 4:
                        err_1 = _a.sent();
                        console.error('Failed: ' + err_1.message);
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Begins connection timeout timer. Used
     * to identify dead connections when we are missing
     * pings from the server
     */
    WebhookRelayClient.prototype.beginCountdown = function () {
        var _this = this;
        clearTimeout(this._countdownTimeout);
        this._countdownTimeout = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this._logger.warn('pings are missing, reconnecting...');
                this._connected = false;
                if (this._socket) {
                    this._socket.close();
                }
                return [2 /*return*/];
            });
        }); }, this._missingPingThreshold);
    };
    /**
     * Disconnects client
     */
    WebhookRelayClient.prototype.disconnect = function () {
        // don't wait for pings anymore
        clearTimeout(this._countdownTimeout);
        this._disconnect();
    };
    Object.defineProperty(WebhookRelayClient.prototype, "isConnecting", {
        /**
         * Checks whether the client is currently connecting to the server.
         */
        get: function () {
            return this._connecting;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebhookRelayClient.prototype, "isConnected", {
        /**
         * Checks whether the client is currently connected to the server.
         */
        get: function () {
            return this._connected;
        },
        enumerable: true,
        configurable: true
    });
    WebhookRelayClient.prototype._disconnect = function () {
        this._connected = false;
        if (this._socket) {
            this._manualDisconnect = true;
            this._socket.close();
        }
    };
    WebhookRelayClient.prototype._reconnect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._connected = false;
                        if (this._socket) {
                            this._socket.close();
                        }
                        return [4 /*yield*/, this.connect()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    WebhookRelayClient.prototype._sendMessage = function (obj) {
        if (this._socket && this._connected) {
            var dataStr = JSON.stringify(obj);
            try {
                this._socket.send(dataStr);
            }
            catch (e) {
                this._logger.error('error while sending message: ', e);
            }
        }
        else {
            this._logger.warn('attempted to send a message on a closed websocket');
        }
    };
    WebhookRelayClient.prototype._receiveMessage = function (dataStr) {
        var msg = WebhookRelayEvent_1.SubscriptionMessage.fromJSON(JSON.parse(dataStr));
        if (msg.getType() === 'status' && msg.getStatus() === 'authenticated') {
            this._sendMessage({ action: 'subscribe', buckets: this._buckets });
            return;
        }
        this.beginCountdown();
        switch (msg.getType()) {
            case 'status':
                if (msg.getStatus() === 'authenticated') {
                    this._sendMessage({ action: 'subscribe', buckets: this._buckets });
                }
                if (msg.getStatus() === 'subscribed') {
                    this._logger.info('subscribed to webhook stream successfully');
                }
                if (msg.getStatus() === 'ping') {
                    this._sendMessage({ action: 'pong' });
                    return;
                }
                if (msg.getStatus() === 'unauthorized') {
                    this._logger.error("authorization failed, key " + this._key);
                }
                this._handler(dataStr);
                return;
            case 'webhook':
                // raw payload
                this._handler(dataStr);
                return;
            default:
                this._logger.warn("unknown message type: " + msg.getType());
                this._handler(dataStr);
                break;
        }
    };
    return WebhookRelayClient;
}());
exports.default = WebhookRelayClient;
